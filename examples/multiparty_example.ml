(* ocamlfind ocamlc -c -rectypes -thread -package session-ocaml,session-ocaml.ppx,session-ocaml.ppx_lens,ppx_deriving examples/multiparty_example.ml *)
open Multiparty
[%%s_syntax_rebind (module Multiparty.Syntax) ]   

(***************
 ** This part will be generated by scribble-ocaml **
 ***************)

type booking
type booking_C = booking_C_1
and booking_C_1 =
  [`send of
    [`Query of [`A] role * string *
      [`recv of [`Quote of [`A] role * int *
        booking_C_1]]
    |`Yes of [`A] role * unit *
      [`send of
        [`Payment of [`S] role * string *
          [`recv of [`Ack of [`S] role * unit *
            booking_C_2]]]]
    |`No of [`A] role * unit *
      booking_C_2]]
and booking_C_2 =
  [`send of
    [`Bye of [`A] role * unit *
      [`close]]]

type booking_S = booking_S_1
and booking_S_1 = 
  [`recv of
    [`Dummy of [`A] role * unit *
      booking_S_1
    |`Yes of [`A] role * unit *
      [`recv of [`Payment of [`C] role * string *
        [`send of 
          [`Ack of [`C] role * unit *
            _EndState]]]]
    |`No of [`A] role * unit *
      _EndState]]
and _EndState = 
  [`close]

type booking_A = booking_A_1
and booking_A_1 = 
  [`recv of
    [`Query of [`C] role * string *
      [`send of 
        [`Quote of [`C] role * int *
          [`send of 
            [`Dummy of [`S] role * unit *
              booking_A_1]]]]
    |`Yes of [`C] role * unit *
      [`send of 
        [`Yes of [`S] role * unit *
          booking_A_2]]
    |`No of [`C] role * unit *
      [`send of 
        [`No of [`S] role * unit *
          booking_A_2]]]]
and booking_A_2 = 
  [`recv of [`Bye of [`C] role * unit *
    [`close]]]
         
let msg_Query = {_pack=(fun a -> `Query(a))}
let msg_Quote = {_pack=(fun a -> `Quote(a))}
let msg_Dummy = {_pack=(fun a -> `Dummy(a))}
let msg_Yes = {_pack=(fun a -> `Yes(a))}
let msg_No = {_pack=(fun a -> `No(a))}
let msg_Payment = {_pack=(fun a -> `Payment(a))}
let msg_Ack = {_pack=(fun a -> `Ack(a))}
let msg_Bye = {_pack=(fun a -> `Bye(a))}

let role_agent : [`A] role = __mkrole "booking_A"
let role_client : [`C] role = __mkrole "booking_C"
let role_server : [`S] role = __mkrole "booking_S"

let connect_C : 'pre 'post. booking channel -> bindto:(empty, booking_C sess, 'pre, 'post) slot -> ('pre,'post,unit) monad =
  fun ch ->
  __connect ~myname:"booking_C" ch

let connect_A : 'pre 'post. booking channel -> bindto:(empty, booking_A sess, 'pre, 'post) slot -> ('pre,'post,unit) monad =
  fun ch ->
  __connect ~myname:"booking_A" ch

let accept_S : 'pre 'post. booking channel -> bindto:(empty, booking_S sess, 'pre, 'post) slot -> ('pre,'post,unit) monad =
  fun ch ->
  __accept ~myname:"booking_S" ~cli_count:2 ch
                        
(***************
 ***************)

let ch = new_channel ()

type ('a,'b) ctx = <s : 'a; t: 'b>
[@@deriving lens]
[@@runner]
            
open Syntax.SessionN


let booking_agent () =

  let rec loop state () =
    match%branch s role_client with
    | `Query((query:string)) -> begin
        
        let quote = 70 in
        send s role_client msg_Quote quote >>
        send s role_server msg_Dummy () >>=
        loop (Some (query,quote))
      end

        
    | `Yes() -> begin

        send s role_server msg_Yes ()
      end

    | `No() -> begin

        send s role_server msg_No ()
      end
  in
  loop None ()
  >>
  match%branch s role_client with `Bye() ->
  close s

let booking_client () =
  send s role_agent msg_Query "from London to Paris, 10th July 2017" >>
  
  match%branch s role_agent with `Quote(price) ->
  (Printf.printf "client: price received: %d" price; return ()) >>

  begin
    if price < 100 then
      begin
        send s role_agent msg_Yes () >>
        send s role_server msg_Payment "123-4567, Nishi-ku, Nagoya, Japan" >>

        match%branch s role_server with (`Ack()) ->
        return ()
      end
    else begin
      send s role_agent msg_No ()
    end
  end >>
  send s role_agent msg_Bye () >>
  close s
      

let booking_server () =

  let rec loop () =
    match%branch s role_agent with
    | `Dummy() -> loop ()
    | `Yes() -> begin
        match%branch s role_client with
        | `Payment(address) ->
           send s role_client msg_Ack ()
      end
    | `No() -> return ()
  in
  loop () >>
  close s

let fork name f () =
  Thread.create (fun () -> print_endline (name ^ ": started."); f (); print_endline (name ^ ": finished.")) ()
  
let _ =
  let t1 = fork "client" (
      run_ctx begin fun () ->
          let%slot #s = connect_C ch in
          booking_client ()
        end) () in
  let t2 = fork "agent" (
      run_ctx begin fun () ->
          let%slot #s = connect_A ch in
          booking_agent ()
        end) () in
  print_endline "server started.";
  run_ctx begin fun () ->
      let%slot #s = accept_S ch in
      booking_server ()
    end ();
  print_endline "server finished.";
  Thread.join t1;
  Thread.join t2;
  ()
  
